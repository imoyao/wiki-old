---
title: 列表
toc: true
tags:
  - 算法
categories:
  - "\U0001F4BB 工作"
  - 数据结构与算法
  - Python_stdin_data_structures
  - list
date: 2020-05-25 18:21:46
---
`List`可能是我们在 `Python` 实际开发中最频繁的数据结构之一。

## `list`内置操作的时间复杂度

| 操作                 | 操作说明                                 | 时间复杂度 |
| -------------------- | -------------------------------------------- | ---------- |
| index(value)         | 查找 list 某个元素的索引              | O(1)       |
| a = index(value)     | 索引赋值                                 | O(1)       |
| append(value)        | 队尾添加                                 | O(1)       |
| pop()                | 队尾删除                                 | O(1)       |
| pop(index)           | 根据索引删除某个元素               | O(n)       |
| insert(index, value) | 根据索引插入某个元素               | O(n)       |
| iterration           | 列表迭代                                 | O(n)       |
| item `in` List         | 列表搜索（in 关键字）                | O(n)       |
| slice [x:y]          | 切片, 获取 x, y 为 O(1), 获取 x,y 中间的值为 O(k) | O(k)       |
| del slice [x:y]      | 删除切片，删除切片后数据需要重新移动/合并 | O(n)       |
| reverse              | 列表反转                                 | O(n)       |
| sort                 | 排序                                       | O(nlogn)   |

`index`和`append`是两个常见操作，它们无论列表多大，操作花费的时间都相同。当
一个操作的速度不因列表的大小发生变化时，其操作复杂度就是 `O(1)`。

随着列表长度的增加，从列表末端删除元素的 `pop()` 操作时间保持稳定，而从列表
开头删除元素的 `pop(x)` 操作则随着长度的增加而增加。参见[代码](./code_test.py)`list_test.py:67`。

说明
当 `pop` 操作每次从列表的最后一位删除元素时复杂度为 `O（1）`，而将列表的第一个元素或中间任意
一个位置的元素删除时，复杂度则为 `O（n）`。这样迥然不同的结果是由 `Python` 对列表的执行方式造
成的。在 `Python` 的执行过程中，当从列表的第一位删除一个元素，其后的每一位元素都将向前挪动
一位。你可能觉得这种操作很愚蠢，但当你仔细看完上表会发现这种执行方式是为了让 `index` 索引
操作的复杂度降为 `O（1）`。这种在运行时间上的权衡是 `Python` 设计者的良苦用心。

## 更多阅读

[Python 内存分析:list 和 array](https://www.cnblogs.com/hellcat/p/8795841.html)